let view
let gesture

let position0 = Point

let interactingEdges = Set()

// goi lien tuc
func gestureDetect() {
    if state == began {
        // goi 1 lan khi bat dau keo
        // position0 = view.position
        rect0 = view.frame
        position0 = gesture.globalposition

        interactingEdges.removeAll()
        if touchTop {
          interactingEdges.add(top)
        }
        ... 3 cai con lai
        return
    }

    if state == changed {
        // goi lien tuc sau lan began
        let translation = globalposition - position0
        let x0, x1, y0, y1 = rect0
        if touchTop {
          y0 += translation.y

          for all_other_y {
            if y0 close to y_i {
              y0 = y_i
            }
          }

          y0 = min(y0, maxY)
          ...
        }
        .. tuong tu 3 cai con lai

        let rect2 = Rect(x0, y0, x1-x0, y1-y0)

        return
    }

    // check truong hop finish
    // code finish
}


  Widget _buildCustomArea() {
    return GestureDetector(
      key: _testKey,
      onTapUp: (details) {
        _onFocusRectangle1(details.globalPosition);
      },
      onTapDown: (details) {
        int? index = _checkInsideRectangle(details.globalPosition);
      },
      onTap: () {
        print("ok");
      },
      onPanUpdate: (details) {
        if (_isInside && _indexOfFocusRect != null) {
          if (_selectedRectangle1 != null) {
            Rectangle1 newRectangle1;
            double x1 = _selectedRectangle1!.x + _selectedRectangle1!.width;
            double y1 = _selectedRectangle1!.y + _selectedRectangle1!.height;
            double y = _selectedRectangle1!.y;
            double x = _selectedRectangle1!.x;

            // translation
            Offset deltaGlobalPosition = details.globalPosition - _startOffset;

            final renderBox = _listGlobalKey[_indexOfFocusRect!]
                .currentContext
                ?.findRenderObject() as RenderBox;
            Offset positionRectangle =
                renderBox.localToGlobal(const Offset(0, 0));
            final renderBox1 =
                _testKey.currentContext?.findRenderObject() as RenderBox;
            final positionRectangle1 = renderBox1.localToGlobal(const Offset(0,0));// Size(391.4, 478.9)
            // maxheight : 409.76413220155314
            // maxwidth : 316.6359203375638
            // ratio: [0.4596713021491782,0.769601195264912]
            List<List<double>> newListOverride = [[], []];
            if (_kiem_tra_xem_dang_o_canh_nao.isNotEmpty) {
              if (_kiem_tra_xem_dang_o_canh_nao.contains("top")) {
                y += deltaGlobalPosition.dy;
                int? result =
                    _snap(positionRectangle.dy, _listVerticalPosition);
                if (result != null) {
                  newListOverride[1].add(_listVerticalPosition[result]);
                  // print("y $y _listVerticalPosition[result] ${_listVerticalPosition[result]}");
                  final newPoint = Offset(0,_listVerticalPosition[result]);
                  final a = renderBox1.globalToLocal(newPoint);
                  print("a ${a}");
                  // 
                }
              }
              if (_kiem_tra_xem_dang_o_canh_nao.contains("left")) {
                x += deltaGlobalPosition.dx;
              }
              if (_kiem_tra_xem_dang_o_canh_nao.contains("right")) {
                x1 += deltaGlobalPosition.dx;
              }
              if (_kiem_tra_xem_dang_o_canh_nao.contains("bottom")) {
                y1 += deltaGlobalPosition.dy;
              }
              x = min(_maxWidth, max(0, x));
              x1 = min(_maxWidth, max(0, x1));
              y = min(_maxHeight, max(0, y));
              y1 = min(_maxHeight, max(0, y1));
            } else {
              var dx = deltaGlobalPosition.dx;
              dx = max(-x, min(dx, _maxWidth - x1));
              var dy = deltaGlobalPosition.dy;
              dy = max(-y, min(dy, _maxHeight - y1));
              x += dx;
              y += dy;
              x1 += dx;
              y1 += dy;
            }
            _listOverride = newListOverride;
            print("_listOverride ${_listOverride}");
            newRectangle1 = Rectangle1(
                id: _selectedRectangle1!.id,
                x: x,
                y: y,
                width: x1 - x,
                height: y1 - y);

            //gan
            _listRectangle1[_indexOfFocusRect!] = newRectangle1;
            setState(() {});
            widget.rerenderFunction();
          }
        }
      },
      onPanStart: (details) {
        if (_indexOfFocusRect != null) {
          _selectedRectangle1 = _listRectangle1[_indexOfFocusRect!];
          _isInside = _checkInsideCurrentRectangle(details.globalPosition,
              checkEdge: true);
          _listVerticalPosition.clear();
          _listHorizontalPosition.clear();
          if (_listRectangle1.isNotEmpty) {
            List<GlobalKey> listGlobalKeyWithoutCurrent =
                List.from(_listGlobalKey);
            listGlobalKeyWithoutCurrent.removeAt(_indexOfFocusRect!);
            _listVerticalPosition =
                convertNestedListToList(listGlobalKeyWithoutCurrent.map((e) {
              int index = listGlobalKeyWithoutCurrent.indexOf(e);
              List<Offset> listEdges = _getLocalEdgePosition(index);
              return [listEdges[1].dy, listEdges[2].dy];
            }).toList());

            _listHorizontalPosition =
                convertNestedListToList(listGlobalKeyWithoutCurrent.map((e) {
              int index = listGlobalKeyWithoutCurrent.indexOf(e);
              List<Offset> listEdges = _getGlobalEdgePosition(index);
              return [listEdges[0].dx, listEdges[3].dx];
            }).toList());
          }
        }
        // check drag from edge ??
        _startOffset = details.globalPosition;
        setState(() {});
        widget.rerenderFunction();
      },
      child: Stack(
        alignment: Alignment.center,
        children: [
          Container(
            alignment: Alignment.center,
            padding: const EdgeInsets.symmetric(vertical: 5),
            child: Container(
              key: _drawAreaKey,
              width: _maxWidth,
              height: _maxHeight,
              decoration:
                  BoxDecoration(color: widget.backgroundColor, boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.2),
                  spreadRadius: 0.5,
                  blurRadius: 5,
                  offset: const Offset(0, 1),
                ),
              ]),
            ),
          ),
          Container(
            alignment: Alignment.center,
            width: _maxWidth + 15,
            height: _maxHeight + 15,
            child: Stack(
              children: [
                Stack(
                  children: _listRectangle1
                      .where((element) => element.id != _selectedRectangle1?.id)
                      .toList()
                      .map<Widget>(
                    (e) {
                      return _buildRectangle1(e);
                    },
                  ).toList(),
                ),
                ..._listOverride[0]
                    .map<Widget>((e) => Positioned(
                        left: e,
                        top: 7,
                        child: Container(
                          height: _maxHeight,
                          // margin: const EdgeInsets.only(left: 7),
                          width: 1,
                          color: colorRed,
                        )))
                    .toList(),
                ..._listOverride[1]
                    .map<Widget>((e) => Positioned(
                        top: e,
                        left: 8,
                        child: Container(
                          height: 1,
                          // margin: const EdgeInsets.only(top: 7),
                          width: _maxWidth,
                          color: colorRed,
                        )))
                    .toList(),
                if (_selectedRectangle1 != null)
                  _buildRectangle1(_selectedRectangle1!),
              ],
            ),
          )
        ],
      ),
    );
  }
